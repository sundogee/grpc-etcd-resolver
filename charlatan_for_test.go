// generated by "charlatan -output=charlatan_for_test.go resolver.ClientConn servicer".  DO NOT EDIT.

package consul

import "reflect"
import "github.com/hashicorp/consul/api"
import "google.golang.org/grpc/resolver"

// ClientConnNewAddressInvocation represents a single call of FakeClientConn.NewAddress
type ClientConnNewAddressInvocation struct {
	Parameters struct {
		Addresses []resolver.Address
	}
}

// ClientConnNewServiceConfigInvocation represents a single call of FakeClientConn.NewServiceConfig
type ClientConnNewServiceConfigInvocation struct {
	Parameters struct {
		ServiceConfig string
	}
}

// ClientConnTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type ClientConnTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeClientConn is a mock implementation of ClientConn for testing.
Use it in your tests as in this example:

	package example

	func TestWithClientConn(t *testing.T) {
		f := &consul.FakeClientConn{
			NewAddressHook: func(addresses []resolver.Address) () {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeNewAddress ...
		f.AssertNewAddressCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeNewAddress.
*/
type FakeClientConn struct {
	NewAddressHook       func([]resolver.Address)
	NewServiceConfigHook func(string)

	NewAddressCalls       []*ClientConnNewAddressInvocation
	NewServiceConfigCalls []*ClientConnNewServiceConfigInvocation
}

// NewFakeClientConnDefaultPanic returns an instance of FakeClientConn with all hooks configured to panic
func NewFakeClientConnDefaultPanic() *FakeClientConn {
	return &FakeClientConn{
		NewAddressHook: func([]resolver.Address) {
			panic("Unexpected call to ClientConn.NewAddress")
		},
		NewServiceConfigHook: func(string) {
			panic("Unexpected call to ClientConn.NewServiceConfig")
		},
	}
}

// NewFakeClientConnDefaultFatal returns an instance of FakeClientConn with all hooks configured to call t.Fatal
func NewFakeClientConnDefaultFatal(t_sym1 ClientConnTestingT) *FakeClientConn {
	return &FakeClientConn{
		NewAddressHook: func([]resolver.Address) {
			t_sym1.Fatal("Unexpected call to ClientConn.NewAddress")
			return
		},
		NewServiceConfigHook: func(string) {
			t_sym1.Fatal("Unexpected call to ClientConn.NewServiceConfig")
			return
		},
	}
}

// NewFakeClientConnDefaultError returns an instance of FakeClientConn with all hooks configured to call t.Error
func NewFakeClientConnDefaultError(t_sym2 ClientConnTestingT) *FakeClientConn {
	return &FakeClientConn{
		NewAddressHook: func([]resolver.Address) {
			t_sym2.Error("Unexpected call to ClientConn.NewAddress")
			return
		},
		NewServiceConfigHook: func(string) {
			t_sym2.Error("Unexpected call to ClientConn.NewServiceConfig")
			return
		},
	}
}

func (f *FakeClientConn) Reset() {
	f.NewAddressCalls = []*ClientConnNewAddressInvocation{}
	f.NewServiceConfigCalls = []*ClientConnNewServiceConfigInvocation{}
}

func (f_sym3 *FakeClientConn) NewAddress(addresses []resolver.Address) {
	if f_sym3.NewAddressHook == nil {
		panic("ClientConn.NewAddress() called but FakeClientConn.NewAddressHook is nil")
	}

	invocation_sym3 := new(ClientConnNewAddressInvocation)
	f_sym3.NewAddressCalls = append(f_sym3.NewAddressCalls, invocation_sym3)

	invocation_sym3.Parameters.Addresses = addresses

	f_sym3.NewAddressHook(addresses)

	return
}

// NewAddressCalled returns true if FakeClientConn.NewAddress was called
func (f *FakeClientConn) NewAddressCalled() bool {
	return len(f.NewAddressCalls) != 0
}

// AssertNewAddressCalled calls t.Error if FakeClientConn.NewAddress was not called
func (f *FakeClientConn) AssertNewAddressCalled(t ClientConnTestingT) {
	t.Helper()
	if len(f.NewAddressCalls) == 0 {
		t.Error("FakeClientConn.NewAddress not called, expected at least one")
	}
}

// NewAddressNotCalled returns true if FakeClientConn.NewAddress was not called
func (f *FakeClientConn) NewAddressNotCalled() bool {
	return len(f.NewAddressCalls) == 0
}

// AssertNewAddressNotCalled calls t.Error if FakeClientConn.NewAddress was called
func (f *FakeClientConn) AssertNewAddressNotCalled(t ClientConnTestingT) {
	t.Helper()
	if len(f.NewAddressCalls) != 0 {
		t.Error("FakeClientConn.NewAddress called, expected none")
	}
}

// NewAddressCalledOnce returns true if FakeClientConn.NewAddress was called exactly once
func (f *FakeClientConn) NewAddressCalledOnce() bool {
	return len(f.NewAddressCalls) == 1
}

// AssertNewAddressCalledOnce calls t.Error if FakeClientConn.NewAddress was not called exactly once
func (f *FakeClientConn) AssertNewAddressCalledOnce(t ClientConnTestingT) {
	t.Helper()
	if len(f.NewAddressCalls) != 1 {
		t.Errorf("FakeClientConn.NewAddress called %d times, expected 1", len(f.NewAddressCalls))
	}
}

// NewAddressCalledN returns true if FakeClientConn.NewAddress was called at least n times
func (f *FakeClientConn) NewAddressCalledN(n int) bool {
	return len(f.NewAddressCalls) >= n
}

// AssertNewAddressCalledN calls t.Error if FakeClientConn.NewAddress was called less than n times
func (f *FakeClientConn) AssertNewAddressCalledN(t ClientConnTestingT, n int) {
	t.Helper()
	if len(f.NewAddressCalls) < n {
		t.Errorf("FakeClientConn.NewAddress called %d times, expected >= %d", len(f.NewAddressCalls), n)
	}
}

// NewAddressCalledWith returns true if FakeClientConn.NewAddress was called with the given values
func (f_sym4 *FakeClientConn) NewAddressCalledWith(addresses []resolver.Address) bool {
	for _, call_sym4 := range f_sym4.NewAddressCalls {
		if reflect.DeepEqual(call_sym4.Parameters.Addresses, addresses) {
			return true
		}
	}

	return false
}

// AssertNewAddressCalledWith calls t.Error if FakeClientConn.NewAddress was not called with the given values
func (f_sym5 *FakeClientConn) AssertNewAddressCalledWith(t ClientConnTestingT, addresses []resolver.Address) {
	t.Helper()
	var found_sym5 bool
	for _, call_sym5 := range f_sym5.NewAddressCalls {
		if reflect.DeepEqual(call_sym5.Parameters.Addresses, addresses) {
			found_sym5 = true
			break
		}
	}

	if !found_sym5 {
		t.Error("FakeClientConn.NewAddress not called with expected parameters")
	}
}

// NewAddressCalledOnceWith returns true if FakeClientConn.NewAddress was called exactly once with the given values
func (f_sym6 *FakeClientConn) NewAddressCalledOnceWith(addresses []resolver.Address) bool {
	var count_sym6 int
	for _, call_sym6 := range f_sym6.NewAddressCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Addresses, addresses) {
			count_sym6++
		}
	}

	return count_sym6 == 1
}

// AssertNewAddressCalledOnceWith calls t.Error if FakeClientConn.NewAddress was not called exactly once with the given values
func (f_sym7 *FakeClientConn) AssertNewAddressCalledOnceWith(t ClientConnTestingT, addresses []resolver.Address) {
	t.Helper()
	var count_sym7 int
	for _, call_sym7 := range f_sym7.NewAddressCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Addresses, addresses) {
			count_sym7++
		}
	}

	if count_sym7 != 1 {
		t.Errorf("FakeClientConn.NewAddress called %d times with expected parameters, expected one", count_sym7)
	}
}

func (f_sym8 *FakeClientConn) NewServiceConfig(serviceConfig string) {
	if f_sym8.NewServiceConfigHook == nil {
		panic("ClientConn.NewServiceConfig() called but FakeClientConn.NewServiceConfigHook is nil")
	}

	invocation_sym8 := new(ClientConnNewServiceConfigInvocation)
	f_sym8.NewServiceConfigCalls = append(f_sym8.NewServiceConfigCalls, invocation_sym8)

	invocation_sym8.Parameters.ServiceConfig = serviceConfig

	f_sym8.NewServiceConfigHook(serviceConfig)

	return
}

// NewServiceConfigCalled returns true if FakeClientConn.NewServiceConfig was called
func (f *FakeClientConn) NewServiceConfigCalled() bool {
	return len(f.NewServiceConfigCalls) != 0
}

// AssertNewServiceConfigCalled calls t.Error if FakeClientConn.NewServiceConfig was not called
func (f *FakeClientConn) AssertNewServiceConfigCalled(t ClientConnTestingT) {
	t.Helper()
	if len(f.NewServiceConfigCalls) == 0 {
		t.Error("FakeClientConn.NewServiceConfig not called, expected at least one")
	}
}

// NewServiceConfigNotCalled returns true if FakeClientConn.NewServiceConfig was not called
func (f *FakeClientConn) NewServiceConfigNotCalled() bool {
	return len(f.NewServiceConfigCalls) == 0
}

// AssertNewServiceConfigNotCalled calls t.Error if FakeClientConn.NewServiceConfig was called
func (f *FakeClientConn) AssertNewServiceConfigNotCalled(t ClientConnTestingT) {
	t.Helper()
	if len(f.NewServiceConfigCalls) != 0 {
		t.Error("FakeClientConn.NewServiceConfig called, expected none")
	}
}

// NewServiceConfigCalledOnce returns true if FakeClientConn.NewServiceConfig was called exactly once
func (f *FakeClientConn) NewServiceConfigCalledOnce() bool {
	return len(f.NewServiceConfigCalls) == 1
}

// AssertNewServiceConfigCalledOnce calls t.Error if FakeClientConn.NewServiceConfig was not called exactly once
func (f *FakeClientConn) AssertNewServiceConfigCalledOnce(t ClientConnTestingT) {
	t.Helper()
	if len(f.NewServiceConfigCalls) != 1 {
		t.Errorf("FakeClientConn.NewServiceConfig called %d times, expected 1", len(f.NewServiceConfigCalls))
	}
}

// NewServiceConfigCalledN returns true if FakeClientConn.NewServiceConfig was called at least n times
func (f *FakeClientConn) NewServiceConfigCalledN(n int) bool {
	return len(f.NewServiceConfigCalls) >= n
}

// AssertNewServiceConfigCalledN calls t.Error if FakeClientConn.NewServiceConfig was called less than n times
func (f *FakeClientConn) AssertNewServiceConfigCalledN(t ClientConnTestingT, n int) {
	t.Helper()
	if len(f.NewServiceConfigCalls) < n {
		t.Errorf("FakeClientConn.NewServiceConfig called %d times, expected >= %d", len(f.NewServiceConfigCalls), n)
	}
}

// NewServiceConfigCalledWith returns true if FakeClientConn.NewServiceConfig was called with the given values
func (f_sym9 *FakeClientConn) NewServiceConfigCalledWith(serviceConfig string) bool {
	for _, call_sym9 := range f_sym9.NewServiceConfigCalls {
		if reflect.DeepEqual(call_sym9.Parameters.ServiceConfig, serviceConfig) {
			return true
		}
	}

	return false
}

// AssertNewServiceConfigCalledWith calls t.Error if FakeClientConn.NewServiceConfig was not called with the given values
func (f_sym10 *FakeClientConn) AssertNewServiceConfigCalledWith(t ClientConnTestingT, serviceConfig string) {
	t.Helper()
	var found_sym10 bool
	for _, call_sym10 := range f_sym10.NewServiceConfigCalls {
		if reflect.DeepEqual(call_sym10.Parameters.ServiceConfig, serviceConfig) {
			found_sym10 = true
			break
		}
	}

	if !found_sym10 {
		t.Error("FakeClientConn.NewServiceConfig not called with expected parameters")
	}
}

// NewServiceConfigCalledOnceWith returns true if FakeClientConn.NewServiceConfig was called exactly once with the given values
func (f_sym11 *FakeClientConn) NewServiceConfigCalledOnceWith(serviceConfig string) bool {
	var count_sym11 int
	for _, call_sym11 := range f_sym11.NewServiceConfigCalls {
		if reflect.DeepEqual(call_sym11.Parameters.ServiceConfig, serviceConfig) {
			count_sym11++
		}
	}

	return count_sym11 == 1
}

// AssertNewServiceConfigCalledOnceWith calls t.Error if FakeClientConn.NewServiceConfig was not called exactly once with the given values
func (f_sym12 *FakeClientConn) AssertNewServiceConfigCalledOnceWith(t ClientConnTestingT, serviceConfig string) {
	t.Helper()
	var count_sym12 int
	for _, call_sym12 := range f_sym12.NewServiceConfigCalls {
		if reflect.DeepEqual(call_sym12.Parameters.ServiceConfig, serviceConfig) {
			count_sym12++
		}
	}

	if count_sym12 != 1 {
		t.Errorf("FakeClientConn.NewServiceConfig called %d times with expected parameters, expected one", count_sym12)
	}
}

// servicerServiceInvocation represents a single call of Fakeservicer.Service
type servicerServiceInvocation struct {
	Parameters struct {
		Ident1 string
		Ident2 string
		Ident3 bool
		Ident4 *api.QueryOptions
	}
	Results struct {
		Ident5 []*api.ServiceEntry
		Ident6 *api.QueryMeta
		Ident7 error
	}
}

// NewservicerServiceInvocation creates a new instance of servicerServiceInvocation
func NewservicerServiceInvocation(ident1 string, ident2 string, ident3 bool, ident4 *api.QueryOptions, ident5 []*api.ServiceEntry, ident6 *api.QueryMeta, ident7 error) *servicerServiceInvocation {
	invocation := new(servicerServiceInvocation)

	invocation.Parameters.Ident1 = ident1
	invocation.Parameters.Ident2 = ident2
	invocation.Parameters.Ident3 = ident3
	invocation.Parameters.Ident4 = ident4

	invocation.Results.Ident5 = ident5
	invocation.Results.Ident6 = ident6
	invocation.Results.Ident7 = ident7

	return invocation
}

// servicerTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type servicerTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
Fakeservicer is a mock implementation of servicer for testing.
Use it in your tests as in this example:

	package example

	func TestWithservicer(t *testing.T) {
		f := &consul.Fakeservicer{
			ServiceHook: func(ident1 string, ident2 string, ident3 bool, ident4 *api.QueryOptions) (ident5 []*api.ServiceEntry, ident6 *api.QueryMeta, ident7 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeService ...
		f.AssertServiceCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeService.
*/
type Fakeservicer struct {
	ServiceHook func(string, string, bool, *api.QueryOptions) ([]*api.ServiceEntry, *api.QueryMeta, error)

	ServiceCalls []*servicerServiceInvocation
}

// NewFakeservicerDefaultPanic returns an instance of Fakeservicer with all hooks configured to panic
func NewFakeservicerDefaultPanic() *Fakeservicer {
	return &Fakeservicer{
		ServiceHook: func(string, string, bool, *api.QueryOptions) (ident5 []*api.ServiceEntry, ident6 *api.QueryMeta, ident7 error) {
			panic("Unexpected call to servicer.Service")
		},
	}
}

// NewFakeservicerDefaultFatal returns an instance of Fakeservicer with all hooks configured to call t.Fatal
func NewFakeservicerDefaultFatal(t_sym13 servicerTestingT) *Fakeservicer {
	return &Fakeservicer{
		ServiceHook: func(string, string, bool, *api.QueryOptions) (ident5 []*api.ServiceEntry, ident6 *api.QueryMeta, ident7 error) {
			t_sym13.Fatal("Unexpected call to servicer.Service")
			return
		},
	}
}

// NewFakeservicerDefaultError returns an instance of Fakeservicer with all hooks configured to call t.Error
func NewFakeservicerDefaultError(t_sym14 servicerTestingT) *Fakeservicer {
	return &Fakeservicer{
		ServiceHook: func(string, string, bool, *api.QueryOptions) (ident5 []*api.ServiceEntry, ident6 *api.QueryMeta, ident7 error) {
			t_sym14.Error("Unexpected call to servicer.Service")
			return
		},
	}
}

func (f *Fakeservicer) Reset() {
	f.ServiceCalls = []*servicerServiceInvocation{}
}

func (f_sym15 *Fakeservicer) Service(ident1 string, ident2 string, ident3 bool, ident4 *api.QueryOptions) (ident5 []*api.ServiceEntry, ident6 *api.QueryMeta, ident7 error) {
	if f_sym15.ServiceHook == nil {
		panic("servicer.Service() called but Fakeservicer.ServiceHook is nil")
	}

	invocation_sym15 := new(servicerServiceInvocation)
	f_sym15.ServiceCalls = append(f_sym15.ServiceCalls, invocation_sym15)

	invocation_sym15.Parameters.Ident1 = ident1
	invocation_sym15.Parameters.Ident2 = ident2
	invocation_sym15.Parameters.Ident3 = ident3
	invocation_sym15.Parameters.Ident4 = ident4

	ident5, ident6, ident7 = f_sym15.ServiceHook(ident1, ident2, ident3, ident4)

	invocation_sym15.Results.Ident5 = ident5
	invocation_sym15.Results.Ident6 = ident6
	invocation_sym15.Results.Ident7 = ident7

	return
}

// SetServiceStub configures servicer.Service to always return the given values
func (f_sym16 *Fakeservicer) SetServiceStub(ident5 []*api.ServiceEntry, ident6 *api.QueryMeta, ident7 error) {
	f_sym16.ServiceHook = func(string, string, bool, *api.QueryOptions) ([]*api.ServiceEntry, *api.QueryMeta, error) {
		return ident5, ident6, ident7
	}
}

// SetServiceInvocation configures servicer.Service to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym17 *Fakeservicer) SetServiceInvocation(calls_sym17 []*servicerServiceInvocation, fallback_sym17 func() ([]*api.ServiceEntry, *api.QueryMeta, error)) {
	f_sym17.ServiceHook = func(ident1 string, ident2 string, ident3 bool, ident4 *api.QueryOptions) (ident5 []*api.ServiceEntry, ident6 *api.QueryMeta, ident7 error) {
		for _, call_sym17 := range calls_sym17 {
			if reflect.DeepEqual(call_sym17.Parameters.Ident1, ident1) && reflect.DeepEqual(call_sym17.Parameters.Ident2, ident2) && reflect.DeepEqual(call_sym17.Parameters.Ident3, ident3) && reflect.DeepEqual(call_sym17.Parameters.Ident4, ident4) {
				ident5 = call_sym17.Results.Ident5
				ident6 = call_sym17.Results.Ident6
				ident7 = call_sym17.Results.Ident7

				return
			}
		}

		return fallback_sym17()
	}
}

// ServiceCalled returns true if Fakeservicer.Service was called
func (f *Fakeservicer) ServiceCalled() bool {
	return len(f.ServiceCalls) != 0
}

// AssertServiceCalled calls t.Error if Fakeservicer.Service was not called
func (f *Fakeservicer) AssertServiceCalled(t servicerTestingT) {
	t.Helper()
	if len(f.ServiceCalls) == 0 {
		t.Error("Fakeservicer.Service not called, expected at least one")
	}
}

// ServiceNotCalled returns true if Fakeservicer.Service was not called
func (f *Fakeservicer) ServiceNotCalled() bool {
	return len(f.ServiceCalls) == 0
}

// AssertServiceNotCalled calls t.Error if Fakeservicer.Service was called
func (f *Fakeservicer) AssertServiceNotCalled(t servicerTestingT) {
	t.Helper()
	if len(f.ServiceCalls) != 0 {
		t.Error("Fakeservicer.Service called, expected none")
	}
}

// ServiceCalledOnce returns true if Fakeservicer.Service was called exactly once
func (f *Fakeservicer) ServiceCalledOnce() bool {
	return len(f.ServiceCalls) == 1
}

// AssertServiceCalledOnce calls t.Error if Fakeservicer.Service was not called exactly once
func (f *Fakeservicer) AssertServiceCalledOnce(t servicerTestingT) {
	t.Helper()
	if len(f.ServiceCalls) != 1 {
		t.Errorf("Fakeservicer.Service called %d times, expected 1", len(f.ServiceCalls))
	}
}

// ServiceCalledN returns true if Fakeservicer.Service was called at least n times
func (f *Fakeservicer) ServiceCalledN(n int) bool {
	return len(f.ServiceCalls) >= n
}

// AssertServiceCalledN calls t.Error if Fakeservicer.Service was called less than n times
func (f *Fakeservicer) AssertServiceCalledN(t servicerTestingT, n int) {
	t.Helper()
	if len(f.ServiceCalls) < n {
		t.Errorf("Fakeservicer.Service called %d times, expected >= %d", len(f.ServiceCalls), n)
	}
}

// ServiceCalledWith returns true if Fakeservicer.Service was called with the given values
func (f_sym18 *Fakeservicer) ServiceCalledWith(ident1 string, ident2 string, ident3 bool, ident4 *api.QueryOptions) bool {
	for _, call_sym18 := range f_sym18.ServiceCalls {
		if reflect.DeepEqual(call_sym18.Parameters.Ident1, ident1) && reflect.DeepEqual(call_sym18.Parameters.Ident2, ident2) && reflect.DeepEqual(call_sym18.Parameters.Ident3, ident3) && reflect.DeepEqual(call_sym18.Parameters.Ident4, ident4) {
			return true
		}
	}

	return false
}

// AssertServiceCalledWith calls t.Error if Fakeservicer.Service was not called with the given values
func (f_sym19 *Fakeservicer) AssertServiceCalledWith(t servicerTestingT, ident1 string, ident2 string, ident3 bool, ident4 *api.QueryOptions) {
	t.Helper()
	var found_sym19 bool
	for _, call_sym19 := range f_sym19.ServiceCalls {
		if reflect.DeepEqual(call_sym19.Parameters.Ident1, ident1) && reflect.DeepEqual(call_sym19.Parameters.Ident2, ident2) && reflect.DeepEqual(call_sym19.Parameters.Ident3, ident3) && reflect.DeepEqual(call_sym19.Parameters.Ident4, ident4) {
			found_sym19 = true
			break
		}
	}

	if !found_sym19 {
		t.Error("Fakeservicer.Service not called with expected parameters")
	}
}

// ServiceCalledOnceWith returns true if Fakeservicer.Service was called exactly once with the given values
func (f_sym20 *Fakeservicer) ServiceCalledOnceWith(ident1 string, ident2 string, ident3 bool, ident4 *api.QueryOptions) bool {
	var count_sym20 int
	for _, call_sym20 := range f_sym20.ServiceCalls {
		if reflect.DeepEqual(call_sym20.Parameters.Ident1, ident1) && reflect.DeepEqual(call_sym20.Parameters.Ident2, ident2) && reflect.DeepEqual(call_sym20.Parameters.Ident3, ident3) && reflect.DeepEqual(call_sym20.Parameters.Ident4, ident4) {
			count_sym20++
		}
	}

	return count_sym20 == 1
}

// AssertServiceCalledOnceWith calls t.Error if Fakeservicer.Service was not called exactly once with the given values
func (f_sym21 *Fakeservicer) AssertServiceCalledOnceWith(t servicerTestingT, ident1 string, ident2 string, ident3 bool, ident4 *api.QueryOptions) {
	t.Helper()
	var count_sym21 int
	for _, call_sym21 := range f_sym21.ServiceCalls {
		if reflect.DeepEqual(call_sym21.Parameters.Ident1, ident1) && reflect.DeepEqual(call_sym21.Parameters.Ident2, ident2) && reflect.DeepEqual(call_sym21.Parameters.Ident3, ident3) && reflect.DeepEqual(call_sym21.Parameters.Ident4, ident4) {
			count_sym21++
		}
	}

	if count_sym21 != 1 {
		t.Errorf("Fakeservicer.Service called %d times with expected parameters, expected one", count_sym21)
	}
}

// ServiceResultsForCall returns the result values for the first call to Fakeservicer.Service with the given values
func (f_sym22 *Fakeservicer) ServiceResultsForCall(ident1 string, ident2 string, ident3 bool, ident4 *api.QueryOptions) (ident5 []*api.ServiceEntry, ident6 *api.QueryMeta, ident7 error, found_sym22 bool) {
	for _, call_sym22 := range f_sym22.ServiceCalls {
		if reflect.DeepEqual(call_sym22.Parameters.Ident1, ident1) && reflect.DeepEqual(call_sym22.Parameters.Ident2, ident2) && reflect.DeepEqual(call_sym22.Parameters.Ident3, ident3) && reflect.DeepEqual(call_sym22.Parameters.Ident4, ident4) {
			ident5 = call_sym22.Results.Ident5
			ident6 = call_sym22.Results.Ident6
			ident7 = call_sym22.Results.Ident7
			found_sym22 = true
			break
		}
	}

	return
}
